<p align="center">Министерство образования, науки и молодежной политики Республики Коми</p>

<p align="center">ГПОУ "Сыктывкарский политехнический техникум"</p>




<p align="center">Курсовая работа</p>


<p align="center">тема: База данных для учета успеваемости школьников </p>


<p align="right"> выполнил </p>

<p align="right">студент 4 курса </p>

<p align="right">414 группы </p>

<p align="right">Логинова Лидия Михайловна</p>



<p align="right">проверил</p>

<p align="right">Пунгин И.В.</p>

<p align="right">дата проверки: </p>






# Задание на курсовую работу по МДК 11.01 "Технология разработки и защиты баз данных"

Специальность: <ins> 09.02.07 "Информационные системы и программирование"  </ins>

Тема курсовой работы:База данных для учета успеваемости школьников

Срок представления работы к защите: <ins> 19 декабря 2025 года. </ins>

Перечень подлежащих разработке вопросов:
1. Анализ предметной области. Постановка задачи.

    1.1. Описание предметной области и функции решаемых задач.

    1.2. Перечень входных данных.

    1.3. Перечень выходных данных

    1.4. Ограничения предметной области (если таковые имеются).

    1.5. Взаимодействие с другими программами.

3. Инфологическая (концептуальная) модель базы данных.

    2.1. Выделение информационных объектов.

    2.2. Определение атрибутов объектов.

    2.3. Определение отношений и мощности отношений между объектами.

    2.4. Построение концептуальной модели.

4. Логическая структура БД.

5. Физическая структура базы данных.

6. Реализация проекта в среде конкретной СУБД.

    6.1. Создание таблиц и индексов.

    6.2. Создание представлений и функций.

    5.3. Разработка интерфейса.

    5.4. Назначение прав доступа.

    5.5. Разработка стратегии резервного копирования базы данных.


Руководитель работы __________________ <ins> И. В. Пунгин </ins>

Задание принял к исполнению _______________________________ <ins> Л. М. Логинова </ins>






## <a id="content">Содержание</a>

1. [Введение](#introduction)
    - [Цель работы](#target)
    - [Задачи работы](#tasks)
2. [Основная часть](#main)
    - [Анализ предметной области. Постановка задачи](#analysis)
    - [Инфологическая (концептуальная) модель базы данных](#infological_model)
    - [Логическая структура БД](#logical_structure)
    - [Физическая структура базы данных](#physical_structure)
    - [Реализация проекта в среде конкретной СУБД](#project_realization)
3. [Заключение](#conclusion)
4. [Список использованных информационных источников](#literature)
5. [Приложения](#applications)


   
## <a id="introduction">Введение</a>

В современном образовательном процессе учет успеваемости учащихся является важным аспектом, влияющим на их академический и профессиональный путь. Эффективное управление информацией о результатах учебы становится необходимостью, что обусловливает актуальность разработки базы данных (БД) для контроля успеваемости. Эта система должна обеспечивать удобный доступ к сведениям для преподавателей, администраторов и студентов, включая сведения о классах, учениках, дисциплинах, оценках и педагогах.

Внедрение базы данных позволит автоматизировать процессы учета успеваемости, сократив время на выполнение рутинных операций и снизив возможность ошибок. Основная задача разработки БД заключается в создании интуитивно понятного интерфейса для ввода, редактирования данных и формирования отчетов. Система должна уметь обрабатывать запросы разной сложности и обеспечивать безопасность информации, включая механизмы защиты от неавторизованного доступа.

Реализация данного проекта создаст эффективную систему, способную хранить и анализировать сведения, что позволит учебным заведениям повысить качество обучения и уровень успеваемости учеников. Таким образом, курсовая работа ориентирована на создание базы данных для мониторинга успеваемости школьников, отвечающей современным стандартам и способствующей оптимизации процесса обучения.


#### <a id="target">Цель работы</a>

Целью данной курсовой работы является разработка базы данных для учета успеваемости школьников, которая позволит эффективно управлять информацией о студентах и их оценках, а также обеспечить доступ к этой информации для различных пользователей. В рамках работы предполагается:
1. Создание структуры базы данных: Разработать схему базы данных, произвести анализ и уточнение структуры, чтобы обеспечить целостность и согласованность данных.
2. Реализация функционала для ввода и обновления данных: Разработка функций для добавления и изменения оценок, а также для управления данными о студентах, учителях и предметах. Это позволит пользователям (учителям и администраторам) легко вводить новые данные, обновлять существующие записи и поддерживать актуальность информации.
3. Создание представлений и запросов для анализа успеваемости: Реализация представлений, которые будут группировать данные о успеваемости учеников по предметам и классам. Это позволит учителям и администраторам быстро получать информацию о текущем уровне успеваемости каждого ученика, а также оценивать общие результаты по классу и предмету.
4. Обеспечение безопасности и управления доступом: Разработка системы прав доступа, которая будет ограничивать возможности пользователей в зависимости от их ролей (учитель, администратор). Это необходимо для защиты конфиденциальной информации о студентах и обеспечения целостности данных.
5. Анализ полученных данных: Проведение анализа успеваемости учеников с использованием созданной базы данных. Это позволит выявить тенденции, проблемы и возможности для улучшения учебного процесса, а также поможет в принятии обоснованных решений по дальнейшему обучению.
6. Документирование процесса разработки: Подготовка технической и эксплуатационной документации, включая описание структуры базы данных, функционала, а также руководства для пользователей. Это обеспечит удобство в использовании системы и поможет в обучении новых пользователей.

Таким образом, цель работы заключается в создании эффективной базы данных для учета успеваемости школьников, которая будет способствовать оптимизации процессов управления учебной информацией и повышению качества образования.


#### <a id="tasks">Задачи работы</a>

Для достижения поставленной цели необходимо решить следующие задачи:

1. **Анализировать предметную область контроля успеваемости школьников** Это включает в себя изучение существующих методов учета успеваемости, требований пользователей (учителей, администраторов и родителей) к системе, а также особенностей образовательного процесса. Важно определить, какую информацию необходимо хранить и обрабатывать, а также выявить ключевые проблемы, которые могут быть решены с помощью базы данных.
2. **Проектировать структуру базы данных.** На этом этапе необходимо определить ключевые таблицы, их атрибуты и связи между сущностями. В частности, следует четко определить структуру таблиц. Важно установить правильные типы данных для каждого атрибута и определить, какие ограничения целостности должны быть применены.
3. **Выбрать и обосновать систему управления базами данных (СУБД)** Необходимо провести анализ различных СУБД (например, MySQL, PostgreSQL, SQLite) с учетом требований проекта, таких как производительность, масштабируемость, простота использования и поддержка необходимых функций. На основании этого анализа следует выбрать наиболее подходящую СУБД и обосновать выбор.
4. **Реализовать структуру базы данных на выбранной СУБД** Это включает в себя написание SQL-запросов для создания таблиц, определения их атрибутов и установления связей между ними. Важно также учесть создание индексов для оптимизации запросов и обеспечения быстрого доступа к данным.
5. **Заполнить базу данных тестовыми данными** Для проверки работоспособности и корректности структуры базы данных необходимо подготовить и вставить тестовые данные в каждую из таблиц. Это позволит убедиться в правильности работы системы и обеспечит возможность тестирования различных функций и запросов.
6. **Разработать и протестировать приложение с использованием Python** для получения необходимых данных. Это включает в себя создание запросов для выборки оценок учеников, получения статистики по успеваемости, а также генерации отчетов для учителей. Важно протестировать эти запросы на корректность и эффективность, убедившись, что они возвращают ожидаемые результаты.
7. **Осуществить тестирование базы данных** На этом этапе необходимо провести комплексное тестирование, чтобы проверить корректность выполнения всех операций, целостность данных и функциональность запросов. Это может включать в себя как ручное тестирование, так и автоматизированные тесты для проверки различных сценариев использования базы данных.
8. **Сформулировать выводы и предложения** по дальнейшему развитию и расширению функционала базы данных. На основе полученных результатов тестирования и анализа работы системы следует сделать выводы о её эффективности, выявить возможные недостатки и предложить пути их устранения. Это может включать в себя рекомендации по улучшению интерфейса, добавлению новых функций или оптимизации структуры базы данных.

Эти задачи направлены на создание эффективного инструмента, который позволит образовательным учреждениям упорядочить данные о успеваемости школьников, автоматизировать ключевые процессы учета и анализа, а также облегчить доступ к информации для всех заинтересованных пользователей.

## <a id="main">Основная часть</a>

#### <a id="analysis">Анализ предметной области. Постановка задачи</a>

1. **Описание предметной области и функции решаемых задач**
    - **Предметная область** данной работы - управление успеваемостью школьников в образовательных учреждениях. Система направлена на автоматизацию процессов учета успеваемости, что позволит учителям эффективно отслеживать достижения учащихся, анализировать их результаты и собственно редактировать значения. Основной целью автоматизации является упрощение работы с данными, надежное хранение данных, повышение прозрачности учебного процесса и улучшение качества образования.
    - **Функции решаемых задач:**
        - **Хранение информации о классах:** Ведение базы данных, содержащей информацию о каждом классе (номер, буква). Это позволит администраторам легко управлять данными о классах и отслеживать их изменения.
        - **Учет учеников:** Сохранение данных о каждом ученике, включая имя, фамилию, отчество, дату рождения и класс. Это обеспечит возможность быстрого доступа к информации о каждом учащемся и его учебной истории.
        - **Ведение оценок:** Запись оценок учеников по каждому предмету с указанием даты урока и учителя. Это позволит формировать полную картину успеваемости каждого ученика и анализировать динамику его успехов.
        - **Обеспечение доступа к информации:** Создание интуитивно понятного интерфейса, который позволит учителям легко находить нужные данные о классах, учениках и их оценках.
        - **Генерация отчетов:** Автоматическое создание отчетов на основе данных, содержащихся в базе, таких как списки учеников с их оценками, статистика успеваемости по классам и предметам, а также информация об учителях их предметах и классах, которые они ведут.
2. **Перечень входных данных.** Для эффективной работы системы необходимы следующие входные данные:
    - **Данные о классах:**
        - Идентификатор класса (ID).
        - Номер класса.
        - Буква класса.
        - Год.
        - Преподаватель.
    - **Данные о преподавателях:**
        - Идентификатор учителя (ID).
        - Имя, фамилия и отчество учителя.
        - Предметы, которые ведет учитель.
        - emile.
        - Логин и пароль, для авторизации.
    - **Данные о учениках:**
        - Идентификатор ученика (ID).
        - Имя, фамилия и отчество ученика.
        - Дата рождения.
        - Класс, к которому принадлежит ученик.
        - Телефон.
        - emile.
        - Логин и пароль, для авторизации.
    - **Данные о предметах:**
        - Идентификатор предмета (ID).
        - Название предмета.
    - **Данные о администраторах:**
        - Идентификатор предмета (ID).
        - Логин и пароль, для авторизации.
    - **Данные о оценках:**
        - Идентификатор оценки (ID).
        - Идентификатор ученика.
        - Идентификатор предмета.
        - Идентификатор класса.
        - Идентификатор учителя.
        - Оценка (в диапазоне от 2 до 5).
        - Номер урока.
        - Дата урока.

3. **Перечень выходных данных.** На основе входных данных система должна предоставить следующие выходные данные:
    - **Отчёт по успеваемости учеников:**
        - Список оценок по предмету у ученика за определенный период.
        - Итоговые оценки за учебные года.
        - Табель оценок по классу.
        - Табель итоговых оценок по классу.
    - **Статистика успеваемости по классам и предметам:**
        - Сравнительный анализ успеваемости класса (изменение оценок за определённый период).
    - **Информация об учителях и их предметах:**
        - Список учителей с указанием предметов и классов которые они ведут.
4. **Ограничения предметной области.** При работе с базой данных могут возникнуть следующие ограничения:
    - **Ограничение по объёму данных:** Увеличение количества учеников, классов и оценок может негативно сказаться на производительности системы. Необходимо учитывать возможность оптимизации базы данных, включая использование индексации и других методов для повышения скорости обработки запросов.
    - **Ограничение по доступу:** Личная информация о учениках и их оценках должна быть защищена от несанкционированного доступа. Это требует реализации надежных механизмов авторизации, чтобы только уполномоченные лица могли получать доступ к конфиденциальной информации.
    - **Ограничение по обновлению данных:** Для предотвращения потери данных необходимо разработать систему резервного копирования. Регулярные бэкапы помогут избежать потерь информации в случае технических сбоев или ошибок пользователей.
5. **Взаимодействие с другими программами.** Система управления успеваемостью может взаимодействовать с различными образовательными и административными системами для расширения функциональности:
    - **Система управления учебным процессом** Интеграция с существующими системами управления учебным процессом позволит автоматизировать обмен данными о расписании уроков, классах и учителях.
    - **Портал для родителей:** Создание веб-портала, где родители смогут отслеживать успеваемость своих детей, получать уведомления о новых оценках и взаимодействовать с учителями.
    - **Система аналитики:** Интеграция с аналитическими платформами (например, Power BI или Google Data Studio) для визуализации данных и создания отчетов, что поможет в анализе успеваемости и выявлении проблемных областей.
    - **Электронный дневник:** Взаимодействие с электронными дневниками, которые позволяют учителям и ученикам отслеживать успеваемость и посещаемость в реальном времени.

#### <a id="infological_model">Инфологическая (концептуальная) модель базы данных</a>

Концептуальная модель базы данных описывает структуру данных, которая будет храниться и обрабатываться в базе, без привязки к конкретной системе управления базами данных (СУБД). В рамках этой модели выделяются ключевые информационные объекты, атрибуты этих объектов, связи между ними, а также мощности отношений, которые определяют тип связей между сущностями.

1. **Выделение информационных объектов.**
    - **Классы** - информация о всех классах за всю историю учебного заведения.
    - **Учителя** - данные о учителях.
    - **Администраторы** - данные об администраторах.
    - **Ученики** - данные о учениках.
    - **Предметы** - информация о том, какие предметы преподаются в учебном заведении.
    - **Оценки** - история всех оценок, за все время.
2. **Определение атрибутов объектов.** Каждая из выделенных сущностей имеют свои уникальные атрибуты, которые описывают их свойства.
    - **Администраторы:**
        - admin_id (Уникальный идентификатор администратора).
        - login.
        - password.
    - **Классы:**
        - class_id (Уникальный идентификатор класса).
        - class_name (Название класса).
        - start_year (Год начала обучения).
        - teacher (Классный руководитель).
    - **Учителя:**
        - teacher_id (Уникальный Идентификатор учителя).
        - first_name (Имя учителя).
	    - last_name (Фамилия учителя).
	    - second_name (Отчество учителя).
        - Предметы, которые ведет учитель.
        - Классы, которые ведет учитель.
        - login.
        - password.
        - emile.
    - **Ученики:**
        - student_id (Уникальный идентификатор ученика).
        - first_name (Имя ученика).
        - last_name (Фамилия ученика).
	    - second_name (Отчество ученика).
        - date_of_birth (Дата рождения).
        - class_id (Класс, к которому принадлежит ученик).
        - emile.
        - adress.
        - phone.
        - login.
        - password.
    - **Предметы:**
        - subject_id (Уникальный идентификатор предмета).
        - subject_name (Название предмета).
    - **Оценки:**
        - grade_id (Идентификатор оценки (ID).
        - student_id (Идентификатор ученика).
        - subject_id (Идентификатор предмета).
        - class_id (Идентификатор класса).
        - teacher_id (Идентификатор учителя).
        - grade (Оценка, в диапазоне от 2 до 5).
        - number_lesson (Номер урока).
        - date_lesson (Дата урока).
        - create_date (Дата создания оценки).
        - update_date (Дата изменения оценки).
3. **Определение отношений и мощности отношений между объектами.** В данной базе данных для контроля успеваемости школьников выделены следующие сущности и их взаимосвязи:
- **Класс — Ученик:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый класс может включать множество учеников, однако каждый ученик может быть зачислен только в один конкретный класс. Это позволяет организовать учебный процесс и контролировать успеваемость в рамках определённой группы учащихся.

- **Учитель - Учитель_Предмет:**
    - **Связь:** один ко многим.
    - **Описание:** Один учитель может преподавать несколько предметов, но каждый предмет может быть преподаваться только одним учителем в рамках данного отношения. Это отношение позволяет гибко распределять нагрузки между учителями и эффективно управлять расписанием.

- **Предмет - Учитель_Предмет:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый предмет может быть связан с несколькими учителями, если, например, в разных классах его ведут разные преподаватели. Однако каждый конкретный учитель может преподавать данный предмет только в рамках своей учебной нагрузки.

- **Ученик - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Один ученик может получать множество оценок по различным предметам на протяжении учебного года. Каждая оценка, в свою очередь, относится только к одному ученику, что позволяет отслеживать его успеваемость и динамику обучения.

- **Предмет - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый предмет может иметь множество оценок, выставленных ученикам. Каждая оценка привязана к конкретному предмету, что позволяет анализировать успеваемость по каждому предмету в отдельности.

- **Учитель - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Один учитель может выставлять множество оценок своим ученикам, но каждая оценка выставляется только одним учителем. Это отношение обеспечивает прозрачность и ответственность в процессе оценки успеваемости.

- **Класс - Оценка:**
    - **Связь:** один ко многим.
    - **Описание:** Каждый класс может иметь множество оценок, выставленных его ученикам. Каждая оценка относится к конкретному классу, что позволяет анализировать успеваемость всего класса в целом.

- **Оценка - Урок:**
    - **Связь:** один ко многим.
    - **Описание:** Каждая оценка относится к конкретному уроку, но один урок может иметь множество оценок, выставленных различным ученикам. Это позволяет детально отслеживать успеваемость на уровне отдельных занятий.

Каждое из этих отношений помогает структурировать данные в базе и обеспечивает возможность глубокого анализа успеваемости школьников, а также управления учебным процессом.

4. **Построение концептуальной модели.** На основе выделенных сущностей, их атрибутов и связей между ними можно построить концептуальную ER-диаграмму для базы данных, предназначенной для контроля успеваемости школьников.

<img width="855" height="750" alt="Снимок экрана 2025-12-17 230558" src="https://github.com/user-attachments/assets/af199cee-e629-45ab-aee3-f93bcdd7e30d" />



Эта концептуальная модель позволяет наглядно представить структуру базы данных, а также связи между различными сущностями, что упрощает дальнейшее проектирование и реализацию системы контроля успеваемости школьников.

#### <a id="logical_structure">Логическая структура базы данных</a>

Логическая структура базы данных представляет собой детализированное описание таблиц, их атрибутов, типов данных, а также ключевых ограничений и правил целостности. На основе концептуальной модели можно построить логическую структуру, которая будет готова для реализации в системе управления базами данных (СУБД).

В данной структуре будут определены следующие таблицы: **Пользователи**, **Классы**, **Учителя**, **Ученики**, **Предметы**, **Домашнее задание**, **Посещаемость**, **Оценки**, **Расписание**, **Родители** а также связи между ними.

#### Определение таблиц и их атрибутов

1. **Таблица "Пользователи"**
    - **admin_id** (Primary Key) - уникальный идентификатор администратора (целое число).
    - **login** - логин администратора (строка).
    - **password** - пароль администратора (строка).

    **Типы данных:**
    - admin_id - SERIAL.
    - login - VARCHAR(50).
    - password - VARCHAR(50).

    **Ограничения:**
    - admin_id является уникальным и не может быть NULL.
    - login является уникальным и не может быть NULL.
    - password не может быть NULL.

2. **Таблица "Классы"**
    - **class_id** (Primary Key) - уникальный идентификатор класса (целое число).
    - **class_number** - номер класса (целое число).
    - **class_letter** - буква класса (строка).
    - **start_year** - год начала обучения (дата).

    **Типы данных:**
    - class_id - SERIAL.
    - class_number - INT.
    - class_letter - VARCHAR(5).
    - start_year - DATE.

    **Ограничения:**
    - class_id является уникальным и не может быть NULL.
    - class_number не может быть NULL.
    - class_letter не может быть NULL.
    - start_year не может быть NULL.

3. **Таблица "Учителя"**
    - **teacher_id** (Primary Key) - уникальный идентификатор учителя (целое число).
    - **first_name** - имя учителя (строка).
    - **last_name** - фамилия учителя (строка).
    - **second_name** - отчество учителя (строка).
    - **login** - логин учителя (строка).
    - **password** - пароль учителя (строка).
    - **deleted** - статус удаления (логическое значение).

    **Типы данных:**
    - teacher_id - SERIAL.
    - first_name - VARCHAR(50).
    - last_name - VARCHAR(50).
    - second_name - VARCHAR(50).
    - login - VARCHAR(50).
    - password - VARCHAR(50).
    - deleted - BOOLEAN.

    **Ограничения:**
    - teacher_id является уникальным и не может быть NULL.
    - login является уникальным и не может быть NULL.
    - password не может быть NULL.

4. **Таблица "Ученики"**
    - **student_id** (Primary Key) - уникальный идентификатор ученика (целое число).
    - **first_name** - имя ученика (строка).
    - **last_name** - фамилия ученика (строка).
    - **second_name** - отчество ученика (строка).
    - **date_of_birth** - дата рождения ученика (дата).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).
    - **login** - логин ученика (строка).
    - **password** - пароль ученика (строка).

    **Типы данных:**
    - student_id - SERIAL.
    - first_name - VARCHAR(50).
    - last_name - VARCHAR(50).
    - second_name - VARCHAR(50).
    - date_of_birth - DATE.
    - class_id - INT.
    - history_classes - VARCHAR(8000).
    - login - VARCHAR(50).
    - password - VARCHAR(50).

    **Ограничения:**
    - student_id является уникальным и не может быть NULL.
    - class_id является внешним ключом, который ссылается на таблицу **Классы**.
    - date_of_birth должна быть меньше текущей даты.


8. **Таблица "Оценки"**
    - **grade_id** (Primary Key) - уникальный идентификатор оценки (целое число).
    - **student_id** (Foreign Key) - ссылка на таблицу **Ученики** (целое число).
    - **class_id** (Foreign Key) - ссылка на таблицу **Классы** (целое число).
    - **subject_id** (Foreign Key) - ссылка на таблицу **Предметы** (целое число).
    - **teacher_id** (Foreign Key) - ссылка на таблицу **Учителя** (целое число).
    - **grade** - оценка (целое число, допустимые значения: 2, 3, 4, 5).
    - **number_lesson** - номер урока (целое число).
    - **date_lesson** - дата урока (дата).
    - **create_date** - дата создания записи (дата).
    - **update_date** - дата обновления записи (дата).

    **Типы данных:**
    - grade_id - SERIAL.
    - student_id - INT.
    - class_id - INT.
    - subject_id - INT.
    - teacher_id - INT.
    - grade - INT.
    - number_lesson - INT.
    - date_lesson - DATE.
    - create_date - DATE.
    - update_date - DATE.

    **Ограничения:**
    - grade_id является уникальным и не может быть NULL.
    - student_id, class_id, subject_id и teacher_id являются внешними ключами, которые ссылаются на соответствующие таблицы.
    - grade должен быть в диапазоне от 2 до 5.


**Нормализация базы данных**

На данном этапе структура базы данных приведена к третьей нормальной форме (3NF), что позволяет:

- Устранить избыточность данных.
- Избежать аномалий при добавлении, изменении и удалении данных.
- Обеспечить более эффективное использование памяти и более быструю обработку запросов.


## <a id="physical_structure">Физическая структура базы данных</a>

Физическая структура базы данных отвечает за реальное хранение данных на физическом уровне, определяет способы хранения и работы с данными, обеспечивая при этом их целостность, доступность и производительность системы. На этом этапе важно учитывать оптимизацию производительности запросов, объёмы данных и ограничения, связанные с физическим хранением данных в выбранной СУБД. В данной курсовой работе предполагается использование реляционной СУБД (PostgreSQL), так как она предоставляет оптимальные средства для управления табличными данными и поддерживает сложные связи между данными, что необходимо для образовательной организации.

Физическая структура проектируется таким образом, чтобы система максимально эффективно обрабатывала данные, предоставляя пользователю доступ к нужной информации с минимальной задержкой. Это достигается с помощью выбора правильных типов данных, индексов, механизмов хранения и настройки параметров, обеспечивающих производительность и надежность.

1. **Выбор типов данных**

Правильный выбор типов данных для полей таблиц — один из ключевых аспектов проектирования физической структуры базы данных, так как это позволяет экономить ресурсы и повышать производительность.

**Рассмотрим выбор типов данных для каждой таблицы:**

- **SERIAL** — используется для автоинкрементных значений, таких как идентификаторы записей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **INT** — используется для целочисленных значений, занимает фиксированный объем памяти и обеспечивает эффективное индексирование, что важно для первичных и внешних ключей. Это подходит для полей, которые используются как ключи и часто участвуют в соединениях и фильтрации данных.
- **VARCHAR(n)** — применяется для хранения текстовых данных переменной длины, таких как имена, названия и описания. Этот тип позволяет оптимально расходовать память, так как фактически занимает объем, соответствующий реальной длине строки.
- **DATE** — этот тип данных используется для хранения дат. Он позволяет хранить значения в формате даты (год, месяц, день) и обеспечивает удобные функции для работы с датами, такие как сравнение и вычисление разницы между датами.
- **BOOLEAN** — используется для хранения логических значений, которые могут принимать два состояния: TRUE (истина) или FALSE (ложь). Он часто используется для представления бинарных состояний, таких как наличие или отсутствие, активный или неактивный статус. Например, поле deleted в таблице Teachers указывает, был ли учитель удален.

Тип данных влияет на объем занимаемой памяти и производительность базы данных, так как данные записываются и извлекаются в зависимости от того, какой тип используется.

**Пример SQL-кода:
-- 1. Таблица для хранения информации о классах
CREATE TABLE classes (
    class_id SERIAL PRIMARY KEY,
    class_name VARCHAR(10) NOT NULL UNIQUE,
    class_teacher_id INT,
    academic_year VARCHAR(9) NOT NULL
);

-- 2. Таблица для хранения информации об учителях
CREATE TABLE teachers (
    teacher_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    birth_date DATE NOT NULL,
    gender CHAR(1) CHECK (gender IN ('М', 'Ж')),
    qualification VARCHAR(100),
    employment_date DATE NOT NULL,
    phone VARCHAR(20),
    email VARCHAR(100) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 3. Добавляем внешний ключ в таблицу classes
ALTER TABLE classes 
ADD CONSTRAINT fk_class_teacher 
FOREIGN KEY (class_teacher_id) 
REFERENCES teachers(teacher_id) ON DELETE SET NULL;

-- 4. Таблица для хранения информации об учениках
CREATE TABLE students (
    student_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    birth_date DATE NOT NULL,
    gender CHAR(1) CHECK (gender IN ('М', 'Ж')),
    class_id INT REFERENCES classes(class_id) ON DELETE SET NULL,
    admission_year INT,
    address TEXT,
    phone VARCHAR(20),
    email VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 5. Таблица для хранения информации о предметах
CREATE TABLE subjects (
    subject_id SERIAL PRIMARY KEY,
    subject_name VARCHAR(100) NOT NULL UNIQUE,
    description TEXT
);

-- 6. Таблица для связи учителей и предметов
CREATE TABLE teacher_subjects (
    teacher_subject_id SERIAL PRIMARY KEY,
    teacher_id INT REFERENCES teachers(teacher_id) ON DELETE CASCADE,
    subject_id INT REFERENCES subjects(subject_id) ON DELETE CASCADE,
    UNIQUE(teacher_id, subject_id)
);

-- 7. Таблица для хранения информации об оценках
CREATE TABLE grades (
    grade_id SERIAL PRIMARY KEY,
    student_id INT REFERENCES students(student_id) ON DELETE CASCADE,
    subject_id INT REFERENCES subjects(subject_id) ON DELETE CASCADE,
    teacher_id INT REFERENCES teachers(teacher_id) ON DELETE SET NULL,
    grade_value INT NOT NULL CHECK (grade_value BETWEEN 1 AND 5),
    grade_date DATE NOT NULL DEFAULT CURRENT_DATE,
    grade_type VARCHAR(20) CHECK (grade_type IN ('текущая', 'контрольная', 'четвертная', 'полугодовая', 'годовая', 'экзамен')),
    lesson_topic VARCHAR(200),
    comment TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 8. Таблица для хранения расписания уроков
CREATE TABLE schedule (
    schedule_id SERIAL PRIMARY KEY,
    class_id INT REFERENCES classes(class_id) ON DELETE CASCADE,
    subject_id INT REFERENCES subjects(subject_id) ON DELETE CASCADE,
    teacher_id INT REFERENCES teachers(teacher_id) ON DELETE SET NULL,
    day_of_week INT CHECK (day_of_week BETWEEN 1 AND 7),
    lesson_number INT CHECK (lesson_number BETWEEN 1 AND 8),
    room_number VARCHAR(10),
    start_date DATE NOT NULL,
    end_date DATE,
    is_active BOOLEAN DEFAULT TRUE
);

-- 9. Таблица для хранения четвертных/полугодовых/годовых оценок
CREATE TABLE term_grades (
    term_grade_id SERIAL PRIMARY KEY,
    student_id INT REFERENCES students(student_id) ON DELETE CASCADE,
    subject_id INT REFERENCES subjects(subject_id) ON DELETE CASCADE,
    teacher_id INT REFERENCES teachers(teacher_id) ON DELETE SET NULL,
    term_number INT CHECK (term_number BETWEEN 1 AND 4),
    academic_year VARCHAR(9) NOT NULL,
    grade_value INT CHECK (grade_value BETWEEN 1 AND 5),
    is_final BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UNIQUE(student_id, subject_id, term_number, academic_year)
);

-- 10. Таблица для хранения посещаемости
CREATE TABLE attendance (
    attendance_id SERIAL PRIMARY KEY,
    student_id INT REFERENCES students(student_id) ON DELETE CASCADE,
    schedule_id INT REFERENCES schedule(schedule_id) ON DELETE CASCADE,
    attendance_date DATE NOT NULL,
    status VARCHAR(20) CHECK (status IN ('присутствовал', 'отсутствовал', 'опоздал', 'болел')),
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 11. Таблица для хранения домашних заданий
CREATE TABLE homeworks (
    homework_id SERIAL PRIMARY KEY,
    schedule_id INT REFERENCES schedule(schedule_id) ON DELETE CASCADE,
    teacher_id INT REFERENCES teachers(teacher_id) ON DELETE CASCADE,
    assignment_text TEXT NOT NULL,
    due_date DATE NOT NULL,
    max_grade INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 12. Таблица для учета сданных домашних заданий
CREATE TABLE homework_submissions (
    submission_id SERIAL PRIMARY KEY,
    homework_id INT REFERENCES homeworks(homework_id) ON DELETE CASCADE,
    student_id INT REFERENCES students(student_id) ON DELETE CASCADE,
    submission_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    submission_text TEXT,
    attachment_url VARCHAR(500),
    grade INT CHECK (grade BETWEEN 1 AND 5),
    teacher_comment TEXT,
    is_submitted BOOLEAN DEFAULT FALSE,
    UNIQUE(homework_id, student_id)
);

-- 13. Таблица для родителей/опекунов
CREATE TABLE parents (
    parent_id SERIAL PRIMARY KEY,
    student_id INT REFERENCES students(student_id) ON DELETE CASCADE,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    relationship VARCHAR(50),
    phone VARCHAR(20) NOT NULL,
    email VARCHAR(100),
    work_place VARCHAR(200),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 14. Таблица для пользователей системы
CREATE TABLE users (
    user_id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    user_type VARCHAR(20) CHECK (user_type IN ('admin', 'teacher', 'student', 'parent')),
    related_id INT,
    is_active BOOLEAN DEFAULT TRUE,
    last_login TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

**Описание и обоснование SQL-кода**

- **Создание таблиц:** Каждая таблица создается с использованием типа SERIAL для первичного ключа, который обеспечивает автоинкремент и уникальность записи. Поля, содержащие важные текстовые данные, используются с типом VARCHAR, а для целочисленных значений и дат применяется тип INT и DATE соответственно.
- **Ограничения целостности:** В таблицах установлены внешние ключи для обеспечения ссылочной целостности. Например, class_id в таблице Students ссылается на таблицу Classes, что гарантирует, что каждый ученик будет принадлежать к существующему классу.
- **Индексы:** Добавлены индексы для полей, которые часто участвуют в запросах.
- **CHECK-ограничения:** Дополнительные ограничения установлены на такие поля, как grade, чтобы защитить базу данных от некорректных значений и обеспечить соответствие данных бизнес-логике.

3. **Разработка интерфейса**

Интерфейс для взаимодействия с базой данных будем создавать с помощью инструментов построения интерфейсов в Python, таких как tkinter. **Основные функции интерфейса должны включать:**

- **Авторизацию** — авторизация под учеником, учителем или администратором.
- **Отображение существующих оценок** — табели оценок, оценки конкретного ученика.
- **Добавление и обновление данных** — формы для изменения оценок у учеников.
- **Анализ данных** — сравнительный анализ успеваемости учащихся.

На языке Python и tkinter можно создать простое приложение, выполняющее данные функции.

4. **Назначение прав доступа**

В целях безопасности база данных может иметь следующие роли:

- **Администратор** — имеет возможность добавлять удалять учителей, редактировать зоны отвественности учителей.
- **Учитель** — может обновлять и контроллировать успеваемость прикрепленных к нему классов, только по тем предметам которые ведет данный учитель.
- **Ученик** — может только просматривать информацию о своих оценках.

5. **Пример кода на python**

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog
import psycopg2
from datetime import datetime
import hashlib

class SchoolDatabaseApp:
    def __init__(self):
        self.conn = None
        self.cursor = None
        self.current_user = None
        self.current_role = None
        
        # Создаем главное окно
        self.root = tk.Tk()
        self.root.title("Школьная информационная система")
        self.root.geometry("1000x700")
        
        # Настройка стилей
        self.setup_styles()
        
        # Показываем окно входа
        self.show_login_window()

        
    def setup_styles(self):
        """Настройка стилей для приложения"""
        style = ttk.Style()
        style.theme_use('clam')
        
        # Цвета
        self.colors = {
            'primary': '#2c3e50',
            'secondary': '#3498db',
            'success': '#27ae60',
            'danger': '#e74c3c',
            'warning': '#f39c12',
            'light': '#ecf0f1',
            'dark': '#2c3e50'
        }
        
    def connect_to_db(self):
        """Подключение к базе данных"""
        try:
            self.conn = psycopg2.connect(
                host="localhost",
                database="school",
                user="school",
                password="1224"
            )
            self.cursor = self.conn.cursor()
            return True
        except Exception as e:
            messagebox.showerror("Ошибка подключения", f"Не удалось подключиться к базе данных:\n{str(e)}")
            return False
    
    def show_login_window(self):
        """Окно входа в систему"""
        self.clear_window()
        
        # Создаем рамку для входа
        login_frame = ttk.Frame(self.root, padding="40")
        login_frame.place(relx=0.5, rely=0.5, anchor="center")
        
        # Заголовок
        title_label = ttk.Label(login_frame, text="Школьная информационная система", 
                                font=("Arial", 20, "bold"), foreground=self.colors['primary'])
        title_label.grid(row=0, column=0, columnspan=2, pady=(0, 30))
        
        # Поле для логина
        ttk.Label(login_frame, text="Логин:", font=("Arial", 12)).grid(row=1, column=0, sticky="e", pady=5)
        self.login_entry = ttk.Entry(login_frame, width=30, font=("Arial", 12))
        self.login_entry.grid(row=1, column=1, pady=5, padx=10)
        self.login_entry.insert(0, "admin")  # Пример логина
        
        # Поле для пароля
        ttk.Label(login_frame, text="Пароль:", font=("Arial", 12)).grid(row=2, column=0, sticky="e", pady=5)
        self.password_entry = ttk.Entry(login_frame, width=30, font=("Arial", 12), show="*")
        self.password_entry.grid(row=2, column=1, pady=5, padx=10)
        self.password_entry.insert(0, "admin")  # Пример пароля
        
        # Кнопка входа
        login_btn = ttk.Button(login_frame, text="Войти", command=self.login, 
                               style="Accent.TButton")
        login_btn.grid(row=3, column=0, columnspan=2, pady=20)
        
        # Информация для тестирования
        info_frame = ttk.LabelFrame(login_frame, text="Тестовые пользователи", padding="10")
        info_frame.grid(row=4, column=0, columnspan=2, pady=10)
        
        info_text = """admin - администратор
i.petrov - учитель (Иван Петров)
alex.ivanov - ученик (Алексей Иванов)
s.ivanov - родитель (Сергей Иванов)
Пароль: admin (для всех тестовых пользователей)"""
        
        ttk.Label(info_frame, text=info_text, justify="left").pack()
        
    def login(self):
        """Авторизация пользователя"""
        username = self.login_entry.get()
        password = self.password_entry.get()
        
        if not username or not password:
            messagebox.showwarning("Ошибка", "Введите логин и пароль")
            return
        
        if not self.connect_to_db():
            return
        
        try:
            # В реальном приложении нужно использовать хеширование паролей
            # Для демонстрации сравниваем напрямую
            self.cursor.execute("""
                SELECT user_id, user_type, related_id, password_hash 
                FROM users 
                WHERE username = %s AND is_active = TRUE
            """, (username,))
            
            user = self.cursor.fetchone()
            
            if user:
                # В демо-версии пропускаем проверку хеша
                # if check_password_hash(user[3], password):
                if True:  # Для демо всегда True
                    self.current_user = {
                        'user_id': user[0],
                        'username': username,
                        'user_type': user[1],
                        'related_id': user[2]
                    }
                    self.current_role = user[1]
                    self.show_main_window()
                else:
                    messagebox.showerror("Ошибка", "Неверный пароль")
            else:
                messagebox.showerror("Ошибка", "Пользователь не найден")
                
        except Exception as e:
            messagebox.showerror("Ошибка", f"Ошибка при авторизации:\n{str(e)}")
    
    def show_main_window(self):
        """Главное окно приложения после входа"""
        self.clear_window()
        
        # Создаем верхнюю панель
        self.create_top_bar()
        
        # Создаем основную область
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.pack(fill="both", expand=True, padx=20, pady=10)
        
        # Показываем вид для текущей роли
        if self.current_role == 'admin':
            self.show_admin_view()
        elif self.current_role == 'teacher':
            self.show_teacher_view()
        elif self.current_role == 'student':
            self.show_student_view()
        elif self.current_role == 'parent':
            self.show_parent_view()
    
    def create_top_bar(self):
        """Создание верхней панели навигации"""
        top_bar = ttk.Frame(self.root, height=60)
        top_bar.pack(fill="x", padx=20, pady=10)
        
        # Информация о пользователе
        user_info = f"{self.current_user['username']} ({self.current_role})"
        user_label = ttk.Label(top_bar, text=user_info, font=("Arial", 12, "bold"))
        user_label.pack(side="left")
        
        # Кнопка выхода
        logout_btn = ttk.Button(top_bar, text="Выйти", command=self.logout)
        logout_btn.pack(side="right")
        
        # Кнопка обновления
        refresh_btn = ttk.Button(top_bar, text="Обновить", command=self.refresh_data)
        refresh_btn.pack(side="right", padx=10)
    
    def show_admin_view(self):
        """Вид для администратора"""
        # Создаем Notebook для вкладок
        notebook = ttk.Notebook(self.main_frame)
        notebook.pack(fill="both", expand=True)
        
        # Вкладка: Пользователи
        users_frame = ttk.Frame(notebook)
        notebook.add(users_frame, text="Пользователи")
        self.create_users_tab(users_frame)
        
        # Вкладка: Ученики
        students_frame = ttk.Frame(notebook)
        notebook.add(students_frame, text="Ученики")
        self.create_students_tab(students_frame)
        
        # Вкладка: Учителя
        teachers_frame = ttk.Frame(notebook)
        notebook.add(teachers_frame, text="Учителя")
        self.create_teachers_tab(teachers_frame)
        
        # Вкладка: Классы
        classes_frame = ttk.Frame(notebook)
        notebook.add(classes_frame, text="Классы")
        self.create_classes_tab(classes_frame)
        
        # Вкладка: Статистика
        stats_frame = ttk.Frame(notebook)
        notebook.add(stats_frame, text="Статистика")
        self.create_stats_tab(stats_frame)
    
    def show_teacher_view(self):
        """Вид для учителя"""
        notebook = ttk.Notebook(self.main_frame)
        notebook.pack(fill="both", expand=True)
        
        # Вкладка: Мои классы
        my_classes_frame = ttk.Frame(notebook)
        notebook.add(my_classes_frame, text="Мои классы")
        self.create_teacher_classes_tab(my_classes_frame)
        
        # Вкладка: Журнал оценок
        grades_frame = ttk.Frame(notebook)
        notebook.add(grades_frame, text="Журнал оценок")
        self.create_teacher_grades_tab(grades_frame)
        
        # Вкладка: Домашние задания
        homework_frame = ttk.Frame(notebook)
        notebook.add(homework_frame, text="Домашние задания")
        self.create_homework_tab(homework_frame)
        
        # Вкладка: Расписание
        schedule_frame = ttk.Frame(notebook)
        notebook.add(schedule_frame, text="Расписание")
        self.create_teacher_schedule_tab(schedule_frame)
    
    def show_student_view(self):
        """Вид для ученика"""
        notebook = ttk.Notebook(self.main_frame)
        notebook.pack(fill="both", expand=True)
        
        # Вкладка: Мои оценки
        grades_frame = ttk.Frame(notebook)
        notebook.add(grades_frame, text="Мои оценки")
        self.create_student_grades_tab(grades_frame)
        
        # Вкладка: Расписание
        schedule_frame = ttk.Frame(notebook)
        notebook.add(schedule_frame, text="Расписание")
        self.create_student_schedule_tab(schedule_frame)
        
        # Вкладка: Домашние задания
        homework_frame = ttk.Frame(notebook)
        notebook.add(homework_frame, text="Домашние задания")
        self.create_student_homework_tab(homework_frame)
        
        # Вкладка: Посещаемость
        attendance_frame = ttk.Frame(notebook)
        notebook.add(attendance_frame, text="Посещаемость")
        self.create_student_attendance_tab(attendance_frame)
    
    def show_parent_view(self):
        """Вид для родителя"""
        notebook = ttk.Notebook(self.main_frame)
        notebook.pack(fill="both", expand=True)
        
        # Вкладка: Дети
        children_frame = ttk.Frame(notebook)
        notebook.add(children_frame, text="Мои дети")
        self.create_parent_children_tab(children_frame)
        
        # Вкладка: Успеваемость
        performance_frame = ttk.Frame(notebook)
        notebook.add(performance_frame, text="Успеваемость")
        self.create_parent_performance_tab(performance_frame)
        
        # Вкладка: Посещаемость
        attendance_frame = ttk.Frame(notebook)
        notebook.add(attendance_frame, text="Посещаемость")
        self.create_parent_attendance_tab(attendance_frame)
        
        # Вкладка: Уведомления
        notifications_frame = ttk.Frame(notebook)
        notebook.add(notifications_frame, text="Уведомления")
        self.create_notifications_tab(notifications_frame)
    
    # ============= АДМИНИСТРАТОР =============
    
    def create_users_tab(self, parent):
        """Вкладка управления пользователями для администратора"""
        # Панель инструментов
        toolbar = ttk.Frame(parent)
        toolbar.pack(fill="x", pady=5)
        
        ttk.Button(toolbar, text="Добавить пользователя", 
                  command=self.add_user).pack(side="left", padx=5)
        ttk.Button(toolbar, text="Редактировать", 
                  command=self.edit_user).pack(side="left", padx=5)
        ttk.Button(toolbar, text="Удалить", 
                  command=self.delete_user).pack(side="left", padx=5)
        
        # Таблица пользователей
        columns = ("ID", "Логин", "Тип", "Связанный ID", "Активен", "Последний вход")
        self.users_tree = ttk.Treeview(parent, columns=columns, show="headings", height=20)
        
        for col in columns:
            self.users_tree.heading(col, text=col)
            self.users_tree.column(col, width=100)
        
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=self.users_tree.yview)
        self.users_tree.configure(yscrollcommand=scrollbar.set)
        
        self.users_tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        self.load_users_data()
    
    def create_students_tab(self, parent):
        """Вкладка управления учениками"""
        toolbar = ttk.Frame(parent)
        toolbar.pack(fill="x", pady=5)
        
        ttk.Button(toolbar, text="Добавить ученика", 
                  command=self.add_student).pack(side="left", padx=5)
        
        columns = ("ID", "Фамилия", "Имя", "Класс", "Дата рождения", "Год поступления")
        self.students_tree = ttk.Treeview(parent, columns=columns, show="headings", height=20)
        
        for col in columns:
            self.students_tree.heading(col, text=col)
            self.students_tree.column(col, width=120)
        
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=self.students_tree.yview)
        self.students_tree.configure(yscrollcommand=scrollbar.set)
        
        self.students_tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        self.load_students_data()
    
    def create_teachers_tab(self, parent):
        """Вкладка управления учителями"""
        toolbar = ttk.Frame(parent)
        toolbar.pack(fill="x", pady=5)
        
        ttk.Button(toolbar, text="Добавить учителя", 
                  command=self.add_teacher).pack(side="left", padx=5)
        
        columns = ("ID", "Фамилия", "Имя", "Дата рождения", "Квалификация", "Дата найма")
        self.teachers_tree = ttk.Treeview(parent, columns=columns, show="headings", height=20)
        
        for col in columns:
            self.teachers_tree.heading(col, text=col)
            self.teachers_tree.column(col, width=120)
        
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=self.teachers_tree.yview)
        self.teachers_tree.configure(yscrollcommand=scrollbar.set)
        
        self.teachers_tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        self.load_teachers_data()
    
    def create_classes_tab(self, parent):
        """Вкладка управления классами"""
        toolbar = ttk.Frame(parent)
        toolbar.pack(fill="x", pady=5)
        
        ttk.Button(toolbar, text="Добавить класс", 
                  command=self.add_class).pack(side="left", padx=5)
        
        columns = ("ID", "Класс", "Классный руководитель", "Учебный год")
        self.classes_tree = ttk.Treeview(parent, columns=columns, show="headings", height=20)
        
        for col in columns:
            self.classes_tree.heading(col, text=col)
            self.classes_tree.column(col, width=150)
        
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=self.classes_tree.yview)
        self.classes_tree.configure(yscrollcommand=scrollbar.set)
        
        self.classes_tree.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")
        
        self.load_classes_data()
    
    def create_stats_tab(self, parent):
        """Вкладка со статистикой"""
        stats_text = tk.Text(parent, wrap="word", height=20, font=("Arial", 10))
        stats_text.pack(fill="both", expand=True, padx=10, pady=10)
        
        try:
            # Статистика по пользователям
            self.cursor.execute("""
                SELECT user_type, COUNT(*) 
                FROM users 
                GROUP BY user_type
            """)
            user_stats = self.cursor.fetchall()
            
            # Статистика по классам
            self.cursor.execute("""
                SELECT class_name, COUNT(s.student_id) 
                FROM classes c
                LEFT JOIN students s ON c.class_id = s.class_id
                GROUP BY c.class_id, c.class_name
            """)
            class_stats = self.cursor.fetchall()
            
            # Статистика по оценкам
            self.cursor.execute("""
                SELECT 
                    AVG(grade_value) as avg_grade,
                    MIN(grade_value) as min_grade,
                    MAX(grade_value) as max_grade,
                    COUNT(*) as total_grades
                FROM grades
            """)
            grade_stats = self.cursor.fetchone()
            
            stats_text.insert("end", "=== СТАТИСТИКА ШКОЛЫ ===\n\n")
            stats_text.insert("end", "1. Пользователи по типам:\n")
            for user_type, count in user_stats:
                stats_text.insert("end", f"   {user_type}: {count}\n")
            
            stats_text.insert("end", "\n2. Количество учеников по классам:\n")
            for class_name, count in class_stats:
                stats_text.insert("end", f"   {class_name}: {count}\n")
            
            stats_text.insert("end", "\n3. Статистика оценок:\n")
            if grade_stats:
                stats_text.insert("end", f"   Средний балл: {grade_stats[0]:.2f}\n")
                stats_text.insert("end", f"   Минимальная оценка: {grade_stats[1]}\n")
                stats_text.insert("end", f"   Максимальная оценка: {grade_stats[2]}\n")
                stats_text.insert("end", f"   Всего оценок: {grade_stats[3]}\n")
            
            stats_text.config(state="disabled")
            
        except Exception as e:
            stats_text.insert("end", f"Ошибка при загрузке статистики: {str(e)}")
    
    # ============= УЧИТЕЛЬ =============
    
    def create_teacher_classes_tab(self, parent):
        """Вкладка 'Мои классы' для учителя"""
        try:
            # Получаем информацию о классах, где учитель является классным руководителем
            self.cursor.execute("""
                SELECT c.class_id, c.class_name, COUNT(s.student_id) as student_count
                FROM classes c
                LEFT JOIN students s ON c.class_id = s.class_id
                WHERE c.class_teacher_id = %s
                GROUP BY c.class_id, c.class_name
            """, (self.current_user['related_id'],))
            
            classes = self.cursor.fetchall()
            
            for i, (class_id, class_name, student_count) in enumerate(classes):
                class_frame = ttk.LabelFrame(parent, text=f"Класс: {class_name}", padding="10")
                class_frame.pack(fill="x", padx=10, pady=5)
                
                ttk.Label(class_frame, text=f"Количество учеников: {student_count}").pack(anchor="w")
                
                # Получаем список учеников класса
                self.cursor.execute("""
                    SELECT student_id, first_name, last_name, birth_date
                    FROM students
                    WHERE class_id = %s
                    ORDER BY last_name, first_name
                """, (class_id,))
                
                students = self.cursor.fetchall()
                
                tree_frame = ttk.Frame(class_frame)
                tree_frame.pack(fill="x", pady=5)
                
                columns = ("ID", "Фамилия", "Имя", "Дата рождения")
                tree = ttk.Treeview(tree_frame, columns=columns, show="headings", height=min(len(students), 10))
                
                for col in columns:
                    tree.heading(col, text=col)
                    tree.column(col, width=100)
                
                for student in students:
                    tree.insert("", "end", values=student)
                
                scrollbar = ttk.Scrollbar(tree_frame, orient="vertical", command=tree.yview)
                tree.configure(yscrollcommand=scrollbar.set)
                
                tree.pack(side="left", fill="both", expand=True)
                scrollbar.pack(side="right", fill="y")
                
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить данные: {str(e)}")
    
    def create_teacher_grades_tab(self, parent):
        """Вкладка 'Журнал оценок' для учителя"""
        # Выбор класса и предмета
        selection_frame = ttk.Frame(parent)
        selection_frame.pack(fill="x", padx=10, pady=10)
        
        ttk.Label(selection_frame, text="Класс:").pack(side="left", padx=5)
        self.class_combo = ttk.Combobox(selection_frame, width=15)
        self.class_combo.pack(side="left", padx=5)
        
        ttk.Label(selection_frame, text="Предмет:").pack(side="left", padx=5)
        self.subject_combo = ttk.Combobox(selection_frame, width=20)
        self.subject_combo.pack(side="left", padx=5)
        
        ttk.Button(selection_frame, text="Загрузить", 
                  command=self.load_grades_for_class).pack(side="left", padx=10)
        
        ttk.Button(selection_frame, text="Добавить оценку", 
                  command=self.add_grade).pack(side="left", padx=5)
        
        # Загружаем классы и предметы
        self.load_teacher_classes_and_subjects()
        
        # Таблица оценок
        self.grades_frame = ttk.Frame(parent)
        self.grades_frame.pack(fill="both", expand=True, padx=10, pady=10)
    
    def create_homework_tab(self, parent):
        """Вкладка 'Домашние задания' для учителя"""
        toolbar = ttk.Frame(parent)
        toolbar.pack(fill="x", padx=10, pady=10)
        
        ttk.Button(toolbar, text="Добавить задание", 
                  command=self.add_homework).pack(side="left", padx=5)
        ttk.Button(toolbar, text="Проверить задания", 
                  command=self.review_homework).pack(side="left", padx=5)
        
        # Таблица заданий
        columns = ("ID", "Предмет", "Класс", "Задание", "Срок", "Сдано", "Проверено")
        self.homework_tree = ttk.Treeview(parent, columns=columns, show="headings", height=15)
        
        for col in columns:
            self.homework_tree.heading(col, text=col)
            self.homework_tree.column(col, width=120)
        
        scrollbar = ttk.Scrollbar(parent, orient="vertical", command=self.homework_tree.yview)
        self.homework_tree.configure(yscrollcommand=scrollbar.set)
        
        self.homework_tree.pack(fill="both", expand=True, padx=10, pady=10)
        scrollbar.pack(side="right", fill="y")
        
        self.load_teacher_homework()
    
    def create_teacher_schedule_tab(self, parent):
        """Вкладка 'Расписание' для учителя"""
        try:
            # Получаем расписание учителя
            self.cursor.execute("""
                SELECT 
                    s.day_of_week,
                    s.lesson_number,
                    c.class_name,
                    sub.subject_name,
                    s.room_number
                FROM schedule s
                JOIN classes c ON s.class_id = c.class_id
                JOIN subjects sub ON s.subject_id = sub.subject_id
                WHERE s.teacher_id = %s AND s.is_active = TRUE
                ORDER BY s.day_of_week, s.lesson_number
            """, (self.current_user['related_id'],))
            
            schedule = self.cursor.fetchall()
            
            days = ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"]
            
            text = tk.Text(parent, wrap="word", height=20, font=("Arial", 10))
            text.pack(fill="both", expand=True, padx=10, pady=10)
            
            current_day = None
            for day_num, lesson_num, class_name, subject_name, room in schedule:
                if day_num != current_day:
                    text.insert("end", f"\n=== {days[day_num-1]} ===\n")
                    current_day = day_num
                
                text.insert("end", f"  {lesson_num}. {subject_name} - {class_name} (каб. {room})\n")
            
            text.config(state="disabled")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить расписание: {str(e)}")
    
    # ============= УЧЕНИК =============
    
    def create_student_grades_tab(self, parent):
        """Вкладка 'Мои оценки' для ученика"""
        try:
            # Получаем оценки ученика
            self.cursor.execute("""
                SELECT 
                    sub.subject_name,
                    g.grade_value,
                    g.grade_date,
                    g.grade_type,
                    g.lesson_topic,
                    t.first_name || ' ' || t.last_name as teacher_name
                FROM grades g
                JOIN subjects sub ON g.subject_id = sub.subject_id
                LEFT JOIN teachers t ON g.teacher_id = t.teacher_id
                WHERE g.student_id = %s
                ORDER BY g.grade_date DESC
            """, (self.current_user['related_id'],))
            
            grades = self.cursor.fetchall()
            
            # Создаем таблицу
            columns = ("Предмет", "Оценка", "Дата", "Тип", "Тема", "Учитель")
            tree = ttk.Treeview(parent, columns=columns, show="headings", height=15)
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            for grade in grades:
                tree.insert("", "end", values=grade)
            
            scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)
            
            tree.pack(side="left", fill="both", expand=True, padx=10, pady=10)
            scrollbar.pack(side="right", fill="y")
            
            # Средние оценки
            self.cursor.execute("""
                SELECT 
                    sub.subject_name,
                    AVG(g.grade_value)::DECIMAL(3,2) as avg_grade
                FROM grades g
                JOIN subjects sub ON g.subject_id = sub.subject_id
                WHERE g.student_id = %s
                GROUP BY sub.subject_name
            """, (self.current_user['related_id'],))
            
            averages = self.cursor.fetchall()
            
            avg_frame = ttk.LabelFrame(parent, text="Средние баллы", padding="10")
            avg_frame.pack(fill="x", padx=10, pady=10)
            
            for subject, avg in averages:
                ttk.Label(avg_frame, text=f"{subject}: {avg}").pack(anchor="w")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить оценки: {str(e)}")
    
    def create_student_schedule_tab(self, parent):
        """Вкладка 'Расписание' для ученика"""
        try:
            # Получаем класс ученика
            self.cursor.execute("""
                SELECT class_id FROM students WHERE student_id = %s
            """, (self.current_user['related_id'],))
            
            class_id = self.cursor.fetchone()[0]
            
            # Получаем расписание
            self.cursor.execute("""
                SELECT 
                    s.day_of_week,
                    s.lesson_number,
                    sub.subject_name,
                    t.first_name || ' ' || t.last_name as teacher_name,
                    s.room_number
                FROM schedule s
                JOIN subjects sub ON s.subject_id = sub.subject_id
                LEFT JOIN teachers t ON s.teacher_id = t.teacher_id
                WHERE s.class_id = %s AND s.is_active = TRUE
                ORDER BY s.day_of_week, s.lesson_number
            """, (class_id,))
            
            schedule = self.cursor.fetchall()
            
            days = ["Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота", "Воскресенье"]
            
            text = tk.Text(parent, wrap="word", height=20, font=("Arial", 10))
            text.pack(fill="both", expand=True, padx=10, pady=10)
            
            current_day = None
            for day_num, lesson_num, subject_name, teacher_name, room in schedule:
                if day_num != current_day:
                    text.insert("end", f"\n=== {days[day_num-1]} ===\n")
                    current_day = day_num
                
                text.insert("end", f"  {lesson_num}. {subject_name}")
                if teacher_name:
                    text.insert("end", f" - {teacher_name}")
                if room:
                    text.insert("end", f" (каб. {room})")
                text.insert("end", "\n")
            
            text.config(state="disabled")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить расписание: {str(e)}")
    
    def create_student_homework_tab(self, parent):
        """Вкладка 'Домашние задания' для ученика"""
        try:
            toolbar = ttk.Frame(parent)
            toolbar.pack(fill="x", padx=10, pady=10)
            
            ttk.Button(toolbar, text="Сдать задание", 
                      command=self.submit_homework).pack(side="left", padx=5)
            
            # Получаем домашние задания
            self.cursor.execute("""
                SELECT 
                    h.homework_id,
                    sub.subject_name,
                    h.assignment_text,
                    h.due_date,
                    hs.grade,
                    hs.is_submitted
                FROM homeworks h
                JOIN schedule sch ON h.schedule_id = sch.schedule_id
                JOIN subjects sub ON sch.subject_id = sub.subject_id
                LEFT JOIN homework_submissions hs ON h.homework_id = hs.homework_id 
                    AND hs.student_id = %s
                WHERE sch.class_id = (SELECT class_id FROM students WHERE student_id = %s)
                    AND h.due_date >= CURRENT_DATE
                ORDER BY h.due_date
            """, (self.current_user['related_id'], self.current_user['related_id']))
            
            homeworks = self.cursor.fetchall()
            
            # Таблица заданий
            columns = ("ID", "Предмет", "Задание", "Срок", "Оценка", "Статус")
            tree = ttk.Treeview(parent, columns=columns, show="headings", height=15)
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            for hw in homeworks:
                status = "Сдано" if hw[5] else "Не сдано"
                grade = hw[4] if hw[4] else "-"
                tree.insert("", "end", values=(hw[0], hw[1], hw[2][:50] + "...", hw[3], grade, status))
            
            scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)
            
            tree.pack(side="left", fill="both", expand=True, padx=10, pady=10)
            scrollbar.pack(side="right", fill="y")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить задания: {str(e)}")
    
    def create_student_attendance_tab(self, parent):
        """Вкладка 'Посещаемость' для ученика"""
        try:
            # Получаем посещаемость ученика
            self.cursor.execute("""
                SELECT 
                    a.attendance_date,
                    sub.subject_name,
                    a.status,
                    a.reason
                FROM attendance a
                JOIN schedule sch ON a.schedule_id = sch.schedule_id
                JOIN subjects sub ON sch.subject_id = sub.subject_id
                WHERE a.student_id = %s
                ORDER BY a.attendance_date DESC
                LIMIT 20
            """, (self.current_user['related_id'],))
            
            attendance = self.cursor.fetchall()
            
            # Создаем таблицу
            columns = ("Дата", "Предмет", "Статус", "Причина")
            tree = ttk.Treeview(parent, columns=columns, show="headings", height=15)
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            for record in attendance:
                tree.insert("", "end", values=record)
            
            scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)
            
            tree.pack(side="left", fill="both", expand=True, padx=10, pady=10)
            scrollbar.pack(side="right", fill="y")
            
            # Статистика посещаемости
            self.cursor.execute("""
                SELECT 
                    COUNT(CASE WHEN status = 'присутствовал' THEN 1 END) as present,
                    COUNT(CASE WHEN status = 'отсутствовал' THEN 1 END) as absent,
                    COUNT(CASE WHEN status = 'болел' THEN 1 END) as sick,
                    COUNT(CASE WHEN status = 'опоздал' THEN 1 END) as late,
                    COUNT(*) as total
                FROM attendance
                WHERE student_id = %s
            """, (self.current_user['related_id'],))
            
            stats = self.cursor.fetchone()
            
            if stats:
                stats_frame = ttk.LabelFrame(parent, text="Статистика посещаемости", padding="10")
                stats_frame.pack(fill="x", padx=10, pady=10)
                
                ttk.Label(stats_frame, text=f"Присутствовал: {stats[0]}").pack(anchor="w")
                ttk.Label(stats_frame, text=f"Отсутствовал: {stats[1]}").pack(anchor="w")
                ttk.Label(stats_frame, text=f"Болел: {stats[2]}").pack(anchor="w")
                ttk.Label(stats_frame, text=f"Опоздал: {stats[3]}").pack(anchor="w")
                
                if stats[4] > 0:
                    percentage = (stats[0] / stats[4]) * 100
                    ttk.Label(stats_frame, text=f"Процент посещаемости: {percentage:.1f}%").pack(anchor="w")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить посещаемость: {str(e)}")
    
    # ============= РОДИТЕЛЬ =============
    
    def create_parent_children_tab(self, parent):
        """Вкладка 'Мои дети' для родителя"""
        try:
            # Получаем детей родителя
            self.cursor.execute("""
                SELECT 
                    s.student_id,
                    s.first_name || ' ' || s.last_name as child_name,
                    c.class_name,
                    t.first_name || ' ' || t.last_name as class_teacher,
                    s.birth_date
                FROM parents p
                JOIN students s ON p.student_id = s.student_id
                JOIN classes c ON s.class_id = c.class_id
                JOIN teachers t ON c.class_teacher_id = t.teacher_id
                WHERE p.parent_id = %s
            """, (self.current_user['related_id'],))
            
            children = self.cursor.fetchall()
            
            for i, (student_id, child_name, class_name, teacher, birth_date) in enumerate(children):
                child_frame = ttk.LabelFrame(parent, text=child_name, padding="10")
                child_frame.pack(fill="x", padx=10, pady=5)
                
                ttk.Label(child_frame, text=f"Класс: {class_name}").pack(anchor="w")
                ttk.Label(child_frame, text=f"Классный руководитель: {teacher}").pack(anchor="w")
                ttk.Label(child_frame, text=f"Дата рождения: {birth_date}").pack(anchor="w")
                
                # Кнопка для просмотра успеваемости
                ttk.Button(child_frame, text="Просмотреть успеваемость",
                          command=lambda sid=student_id: self.show_child_grades(sid)).pack(anchor="w", pady=5)
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить данные о детях: {str(e)}")
    
    def create_parent_performance_tab(self, parent):
        """Вкладка 'Успеваемость' для родителя"""
        try:
            # Получаем детей
            self.cursor.execute("""
                SELECT s.student_id, s.first_name || ' ' || s.last_name as child_name
                FROM parents p
                JOIN students s ON p.student_id = s.student_id
                WHERE p.parent_id = %s
            """, (self.current_user['related_id'],))
            
            children = self.cursor.fetchall()
            
            if not children:
                ttk.Label(parent, text="Нет данных о детях").pack(pady=20)
                return
            
            # Выбор ребенка
            selection_frame = ttk.Frame(parent)
            selection_frame.pack(fill="x", padx=10, pady=10)
            
            ttk.Label(selection_frame, text="Ребенок:").pack(side="left", padx=5)
            self.child_combo = ttk.Combobox(selection_frame, width=30)
            self.child_combo['values'] = [f"{name} (ID: {sid})" for sid, name in children]
            if children:
                self.child_combo.set(f"{children[0][1]} (ID: {children[0][0]})")
            self.child_combo.pack(side="left", padx=5)
            
            ttk.Button(selection_frame, text="Показать успеваемость",
                      command=self.show_child_performance).pack(side="left", padx=10)
            
            # Область для отображения успеваемости
            self.performance_text = tk.Text(parent, wrap="word", height=20, font=("Arial", 10))
            self.performance_text.pack(fill="both", expand=True, padx=10, pady=10)
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить данные: {str(e)}")
    
    def create_parent_attendance_tab(self, parent):
        """Вкладка 'Посещаемость' для родителя"""
        try:
            # Получаем детей
            self.cursor.execute("""
                SELECT s.student_id, s.first_name || ' ' || s.last_name as child_name
                FROM parents p
                JOIN students s ON p.student_id = s.student_id
                WHERE p.parent_id = %s
            """, (self.current_user['related_id'],))
            
            children = self.cursor.fetchall()
            
            if not children:
                ttk.Label(parent, text="Нет данных о детях").pack(pady=20)
                return
            
            # Выбор ребенка
            selection_frame = ttk.Frame(parent)
            selection_frame.pack(fill="x", padx=10, pady=10)
            
            ttk.Label(selection_frame, text="Ребенок:").pack(side="left", padx=5)
            self.attendance_child_combo = ttk.Combobox(selection_frame, width=30)
            self.attendance_child_combo['values'] = [f"{name} (ID: {sid})" for sid, name in children]
            if children:
                self.attendance_child_combo.set(f"{children[0][1]} (ID: {children[0][0]})")
            self.attendance_child_combo.pack(side="left", padx=5)
            
            ttk.Button(selection_frame, text="Показать посещаемость",
                      command=self.show_child_attendance).pack(side="left", padx=10)
            
            # Область для отображения посещаемости
            self.attendance_text = tk.Text(parent, wrap="word", height=20, font=("Arial", 10))
            self.attendance_text.pack(fill="both", expand=True, padx=10, pady=10)
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить данные: {str(e)}")
    
    def create_notifications_tab(self, parent):
        """Вкладка 'Уведомления' для родителя"""
        try:
            # Получаем уведомления
            self.cursor.execute("""
                SELECT 
                    n.title,
                    n.message,
                    n.notification_type,
                    n.created_at,
                    n.is_read
                FROM notifications n
                JOIN users u ON n.user_id = u.user_id
                WHERE u.username = %s OR u.related_id = %s
                ORDER BY n.created_at DESC
            """, (self.current_user['username'], self.current_user['related_id']))
            
            notifications = self.cursor.fetchall()
            
            # Таблица уведомлений
            columns = ("Заголовок", "Тип", "Дата", "Прочитано")
            tree = ttk.Treeview(parent, columns=columns, show="headings", height=15)
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=150)
            
            for notif in notifications:
                read_status = "Да" if notif[4] else "Нет"
                tree.insert("", "end", values=(notif[0], notif[2], notif[3], read_status))
            
            scrollbar = ttk.Scrollbar(parent, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)
            
            tree.pack(side="left", fill="both", expand=True, padx=10, pady=10)
            scrollbar.pack(side="right", fill="y")
            
            # Двойной клик для просмотра сообщения
            tree.bind("<Double-1>", lambda e: self.show_notification_message(tree))
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить уведомления: {str(e)}")
    
    # ============= ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ =============
    
    def load_users_data(self):
        """Загрузка данных пользователей"""
        try:
            self.cursor.execute("""
                SELECT user_id, username, user_type, related_id, is_active, last_login
                FROM users
                ORDER BY user_id
            """)
            
            # Очищаем существующие данные
            for item in self.users_tree.get_children():
                self.users_tree.delete(item)
            
            # Добавляем новые данные
            for user in self.cursor.fetchall():
                is_active = "Да" if user[4] else "Нет"
                last_login = user[5].strftime("%Y-%m-%d %H:%M") if user[5] else "-"
                self.users_tree.insert("", "end", values=(user[0], user[1], user[2], 
                                                         user[3] if user[3] else "-", 
                                                         is_active, last_login))
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить пользователей: {str(e)}")
    
    def load_students_data(self):
        """Загрузка данных учеников"""
        try:
            self.cursor.execute("""
                SELECT s.student_id, s.last_name, s.first_name, c.class_name, 
                       s.birth_date, s.admission_year
                FROM students s
                LEFT JOIN classes c ON s.class_id = c.class_id
                ORDER BY c.class_name, s.last_name, s.first_name
            """)
            
            for item in self.students_tree.get_children():
                self.students_tree.delete(item)
            
            for student in self.cursor.fetchall():
                self.students_tree.insert("", "end", values=student)
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить учеников: {str(e)}")
    
    def load_teachers_data(self):
        """Загрузка данных учителей"""
        try:
            self.cursor.execute("""
                SELECT teacher_id, last_name, first_name, birth_date, 
                       qualification, employment_date
                FROM teachers
                ORDER BY last_name, first_name
            """)
            
            for item in self.teachers_tree.get_children():
                self.teachers_tree.delete(item)
            
            for teacher in self.cursor.fetchall():
                self.teachers_tree.insert("", "end", values=teacher)
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить учителей: {str(e)}")
    
    def load_classes_data(self):
        """Загрузка данных классов"""
        try:
            self.cursor.execute("""
                SELECT c.class_id, c.class_name, 
                       t.first_name || ' ' || t.last_name as teacher_name,
                       c.academic_year
                FROM classes c
                LEFT JOIN teachers t ON c.class_teacher_id = t.teacher_id
                ORDER BY c.class_name
            """)
            
            for item in self.classes_tree.get_children():
                self.classes_tree.delete(item)
            
            for class_info in self.cursor.fetchall():
                self.classes_tree.insert("", "end", values=class_info)
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить классы: {str(e)}")
    
    def load_teacher_classes_and_subjects(self):
        """Загрузка классов и предметов для учителя"""
        try:
            # Классы, в которых преподает учитель
            self.cursor.execute("""
                SELECT DISTINCT c.class_id, c.class_name
                FROM schedule s
                JOIN classes c ON s.class_id = c.class_id
                WHERE s.teacher_id = %s
                ORDER BY c.class_name
            """, (self.current_user['related_id'],))
            
            classes = self.cursor.fetchall()
            self.class_combo['values'] = [f"{name} (ID: {cid})" for cid, name in classes]
            if classes:
                self.class_combo.set(f"{classes[0][1]} (ID: {classes[0][0]})")
            
            # Предметы, которые преподает учитель
            self.cursor.execute("""
                SELECT DISTINCT sub.subject_id, sub.subject_name
                FROM teacher_subjects ts
                JOIN subjects sub ON ts.subject_id = sub.subject_id
                WHERE ts.teacher_id = %s
                ORDER BY sub.subject_name
            """, (self.current_user['related_id'],))
            
            subjects = self.cursor.fetchall()
            self.subject_combo['values'] = [f"{name} (ID: {sid})" for sid, name in subjects]
            if subjects:
                self.subject_combo.set(f"{subjects[0][1]} (ID: {subjects[0][0]})")
                
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить данные: {str(e)}")
    
    def load_grades_for_class(self):
        """Загрузка оценок для выбранного класса и предмета"""
        try:
            # Извлекаем ID из строки в комбобоксе
            class_str = self.class_combo.get()
            subject_str = self.subject_combo.get()
            
            if not class_str or not subject_str:
                messagebox.showwarning("Ошибка", "Выберите класс и предмет")
                return
            
            class_id = int(class_str.split("(ID: ")[1].rstrip(")"))
            subject_id = int(subject_str.split("(ID: ")[1].rstrip(")"))
            
            # Очищаем предыдущие данные
            for widget in self.grades_frame.winfo_children():
                widget.destroy()
            
            # Получаем учеников класса
            self.cursor.execute("""
                SELECT student_id, first_name, last_name
                FROM students
                WHERE class_id = %s
                ORDER BY last_name, first_name
            """, (class_id,))
            
            students = self.cursor.fetchall()
            
            if not students:
                ttk.Label(self.grades_frame, text="В классе нет учеников").pack(pady=20)
                return
            
            # Создаем таблицу с оценками
            columns = ["Ученик"] + [f"Оценка {i+1}" for i in range(10)] + ["Средний"]
            
            tree = ttk.Treeview(self.grades_frame, columns=columns, show="headings", height=min(len(students), 20))
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=80)
            
            for student_id, first_name, last_name in students:
                # Получаем оценки ученика по предмету
                self.cursor.execute("""
                    SELECT grade_value, grade_date
                    FROM grades
                    WHERE student_id = %s AND subject_id = %s
                    ORDER BY grade_date
                    LIMIT 10
                """, (student_id, subject_id))
                
                grades = self.cursor.fetchall()
                
                # Рассчитываем средний балл
                self.cursor.execute("""
                    SELECT AVG(grade_value)::DECIMAL(3,2)
                    FROM grades
                    WHERE student_id = %s AND subject_id = %s
                """, (student_id, subject_id))
                
                avg_result = self.cursor.fetchone()
                avg_grade = avg_result[0] if avg_result[0] else "-"
                
                # Формируем строку для таблицы
                values = [f"{last_name} {first_name}"]
                for i in range(10):
                    if i < len(grades):
                        values.append(str(grades[i][0]))
                    else:
                        values.append("")
                values.append(str(avg_grade))
                
                tree.insert("", "end", values=values)
            
            scrollbar = ttk.Scrollbar(self.grades_frame, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)
            
            tree.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить оценки: {str(e)}")
    
    def load_teacher_homework(self):
        """Загрузка домашних заданий для учителя"""
        try:
            self.cursor.execute("""
                SELECT 
                    h.homework_id,
                    sub.subject_name,
                    c.class_name,
                    h.assignment_text,
                    h.due_date,
                    COUNT(hs.submission_id) as submitted_count,
                    COUNT(CASE WHEN hs.grade IS NOT NULL THEN 1 END) as graded_count
                FROM homeworks h
                JOIN schedule sch ON h.schedule_id = sch.schedule_id
                JOIN classes c ON sch.class_id = c.class_id
                JOIN subjects sub ON sch.subject_id = sub.subject_id
                LEFT JOIN homework_submissions hs ON h.homework_id = hs.homework_id
                WHERE h.teacher_id = %s
                GROUP BY h.homework_id, sub.subject_name, c.class_name, h.assignment_text, h.due_date
                ORDER BY h.due_date
            """, (self.current_user['related_id'],))
            
            homeworks = self.cursor.fetchall()
            
            for item in self.homework_tree.get_children():
                self.homework_tree.delete(item)
            
            for hw in homeworks:
                self.homework_tree.insert("", "end", values=(
                    hw[0], hw[1], hw[2], hw[3][:50] + "...", hw[4], hw[5], hw[6]
                ))
                
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить задания: {str(e)}")
    
    def show_child_grades(self, student_id):
        """Показать успеваемость ребенка"""
        try:
            # Создаем новое окно
            child_window = tk.Toplevel(self.root)
            child_window.title("Успеваемость ученика")
            child_window.geometry("800x600")
            
            # Получаем информацию об ученике
            self.cursor.execute("""
                SELECT first_name || ' ' || last_name, class_id
                FROM students WHERE student_id = %s
            """, (student_id,))
            
            student_info = self.cursor.fetchone()
            child_window.title(f"Успеваемость: {student_info[0]}")
            
            # Получаем оценки
            self.cursor.execute("""
                SELECT 
                    sub.subject_name,
                    g.grade_value,
                    g.grade_date,
                    g.grade_type,
                    g.lesson_topic
                FROM grades g
                JOIN subjects sub ON g.subject_id = sub.subject_id
                WHERE g.student_id = %s
                ORDER BY g.grade_date DESC
            """, (student_id,))
            
            grades = self.cursor.fetchall()
            
            # Создаем таблицу
            columns = ("Предмет", "Оценка", "Дата", "Тип", "Тема")
            tree = ttk.Treeview(child_window, columns=columns, show="headings", height=20)
            
            for col in columns:
                tree.heading(col, text=col)
                tree.column(col, width=120)
            
            for grade in grades:
                tree.insert("", "end", values=grade)
            
            scrollbar = ttk.Scrollbar(child_window, orient="vertical", command=tree.yview)
            tree.configure(yscrollcommand=scrollbar.set)
            
            tree.pack(side="left", fill="both", expand=True, padx=10, pady=10)
            scrollbar.pack(side="right", fill="y")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить успеваемость: {str(e)}")
    
    def show_child_performance(self):
        """Показать успеваемость выбранного ребенка"""
        try:
            # Извлекаем ID ученика
            child_str = self.child_combo.get()
            if not child_str:
                return
            
            student_id = int(child_str.split("(ID: ")[1].rstrip(")"))
            
            # Очищаем текстовое поле
            self.performance_text.delete(1.0, tk.END)
            
            # Получаем оценки по предметам
            self.cursor.execute("""
                SELECT 
                    sub.subject_name,
                    AVG(g.grade_value)::DECIMAL(3,2) as average_grade,
                    COUNT(g.grade_id) as grades_count,
                    MIN(g.grade_value) as min_grade,
                    MAX(g.grade_value) as max_grade
                FROM grades g
                JOIN subjects sub ON g.subject_id = sub.subject_id
                WHERE g.student_id = %s
                GROUP BY sub.subject_name
                ORDER BY sub.subject_name
            """, (student_id,))
            
            subjects = self.cursor.fetchall()
            
            self.performance_text.insert("end", "=== УСПЕВАЕМОСТЬ ===\n\n")
            
            if subjects:
                for subject, avg, count, min_g, max_g in subjects:
                    self.performance_text.insert("end", f"Предмет: {subject}\n")
                    self.performance_text.insert("end", f"  Средний балл: {avg}\n")
                    self.performance_text.insert("end", f"  Количество оценок: {count}\n")
                    self.performance_text.insert("end", f"  Минимальная оценка: {min_g}\n")
                    self.performance_text.insert("end", f"  Максимальная оценка: {max_g}\n\n")
            else:
                self.performance_text.insert("end", "Нет данных об оценках\n")
            
            # Получаем четвертные оценки
            self.cursor.execute("""
                SELECT 
                    sub.subject_name,
                    tg.term_number,
                    tg.grade_value,
                    tg.academic_year
                FROM term_grades tg
                JOIN subjects sub ON tg.subject_id = sub.subject_id
                WHERE tg.student_id = %s
                ORDER BY tg.academic_year DESC, tg.term_number, sub.subject_name
            """, (student_id,))
            
            term_grades = self.cursor.fetchall()
            
            if term_grades:
                self.performance_text.insert("end", "\n=== ЧЕТВЕРТНЫЕ ОЦЕНКИ ===\n\n")
                
                current_year = None
                current_term = None
                
                for subject, term, grade, year in term_grades:
                    if year != current_year:
                        self.performance_text.insert("end", f"\nУчебный год: {year}\n")
                        current_year = year
                        current_term = None
                    
                    if term != current_term:
                        self.performance_text.insert("end", f"  {term}-я четверть:\n")
                        current_term = term
                    
                    self.performance_text.insert("end", f"    {subject}: {grade}\n")
            
            self.performance_text.config(state="disabled")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить успеваемость: {str(e)}")
    
    def show_child_attendance(self):
        """Показать посещаемость выбранного ребенка"""
        try:
            # Извлекаем ID ученика
            child_str = self.attendance_child_combo.get()
            if not child_str:
                return
            
            student_id = int(child_str.split("(ID: ")[1].rstrip(")"))
            
            # Очищаем текстовое поле
            self.attendance_text.delete(1.0, tk.END)
            
            # Получаем статистику посещаемости
            self.cursor.execute("""
                SELECT 
                    COUNT(CASE WHEN status = 'присутствовал' THEN 1 END) as present,
                    COUNT(CASE WHEN status = 'отсутствовал' THEN 1 END) as absent,
                    COUNT(CASE WHEN status = 'болел' THEN 1 END) as sick,
                    COUNT(CASE WHEN status = 'опоздал' THEN 1 END) as late,
                    COUNT(*) as total
                FROM attendance
                WHERE student_id = %s
            """, (student_id,))
            
            stats = self.cursor.fetchone()
            
            self.attendance_text.insert("end", "=== СТАТИСТИКА ПОСЕЩАЕМОСТИ ===\n\n")
            
            if stats:
                self.attendance_text.insert("end", f"Всего уроков: {stats[4]}\n")
                self.attendance_text.insert("end", f"Присутствовал: {stats[0]}\n")
                self.attendance_text.insert("end", f"Отсутствовал: {stats[1]}\n")
                self.attendance_text.insert("end", f"Болел: {stats[2]}\n")
                self.attendance_text.insert("end", f"Опоздал: {stats[3]}\n")
                
                if stats[4] > 0:
                    percentage = (stats[0] / stats[4]) * 100
                    self.attendance_text.insert("end", f"\nПроцент посещаемости: {percentage:.1f}%\n")
            
            # Последние пропуски
            self.cursor.execute("""
                SELECT 
                    a.attendance_date,
                    sub.subject_name,
                    a.status,
                    a.reason
                FROM attendance a
                JOIN schedule sch ON a.schedule_id = sch.schedule_id
                JOIN subjects sub ON sch.subject_id = sub.subject_id
                WHERE a.student_id = %s AND a.status != 'присутствовал'
                ORDER BY a.attendance_date DESC
                LIMIT 10
            """, (student_id,))
            
            absences = self.cursor.fetchall()
            
            if absences:
                self.attendance_text.insert("end", "\n=== ПОСЛЕДНИЕ ПРОПУСКИ ===\n\n")
                
                for date, subject, status, reason in absences:
                    self.attendance_text.insert("end", f"Дата: {date}\n")
                    self.attendance_text.insert("end", f"Предмет: {subject}\n")
                    self.attendance_text.insert("end", f"Статус: {status}\n")
                    if reason:
                        self.attendance_text.insert("end", f"Причина: {reason}\n")
                    self.attendance_text.insert("end", "---\n")
            
            self.attendance_text.config(state="disabled")
            
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось загрузить посещаемость: {str(e)}")
    
    def show_notification_message(self, tree):
        """Показать полный текст уведомления"""
        selection = tree.selection()
        if not selection:
            return
        
        item = tree.item(selection[0])
        title = item['values'][0]
        
        # В реальном приложении нужно получать полное сообщение из БД
        messagebox.showinfo(title, "Полный текст уведомления будет здесь")
    
    # ============= ДИАЛОГИ ДОБАВЛЕНИЯ/РЕДАКТИРОВАНИЯ =============
    
    def add_user(self):
        """Диалог добавления пользователя"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Добавить пользователя")
        dialog.geometry("400x300")
        
        # Поля формы
        ttk.Label(dialog, text="Логин:").grid(row=0, column=0, sticky="e", padx=5, pady=5)
        username_entry = ttk.Entry(dialog, width=30)
        username_entry.grid(row=0, column=1, padx=5, pady=5)
        
        ttk.Label(dialog, text="Пароль:").grid(row=1, column=0, sticky="e", padx=5, pady=5)
        password_entry = ttk.Entry(dialog, width=30, show="*")
        password_entry.grid(row=1, column=1, padx=5, pady=5)
        
        ttk.Label(dialog, text="Тип:").grid(row=2, column=0, sticky="e", padx=5, pady=5)
        user_type_combo = ttk.Combobox(dialog, values=["admin", "teacher", "student", "parent"], width=27)
        user_type_combo.grid(row=2, column=1, padx=5, pady=5)
        user_type_combo.set("student")
        
        ttk.Label(dialog, text="Связанный ID:").grid(row=3, column=0, sticky="e", padx=5, pady=5)
        related_id_entry = ttk.Entry(dialog, width=30)
        related_id_entry.grid(row=3, column=1, padx=5, pady=5)
        
        def save_user():
            username = username_entry.get()
            password = password_entry.get()
            user_type = user_type_combo.get()
            related_id = related_id_entry.get()
            
            if not username or not password or not user_type:
                messagebox.showwarning("Ошибка", "Заполните обязательные поля")
                return
            
            try:
                related_id_int = int(related_id) if related_id else None
                
                # В реальном приложении нужно хешировать пароль
                password_hash = "demo_hash"  # Заменить на реальное хеширование
                
                self.cursor.execute("""
                    INSERT INTO users (username, password_hash, user_type, related_id, is_active)
                    VALUES (%s, %s, %s, %s, TRUE)
                """, (username, password_hash, user_type, related_id_int))
                
                self.conn.commit()
                messagebox.showinfo("Успех", "Пользователь добавлен")
                dialog.destroy()
                self.load_users_data()
                
            except Exception as e:
                messagebox.showerror("Ошибка", f"Не удалось добавить пользователя:\n{str(e)}")
                self.conn.rollback()
        
        # Кнопки
        button_frame = ttk.Frame(dialog)
        button_frame.grid(row=4, column=0, columnspan=2, pady=20)
        
        ttk.Button(button_frame, text="Сохранить", command=save_user).pack(side="left", padx=5)
        ttk.Button(button_frame, text="Отмена", command=dialog.destroy).pack(side="left", padx=5)
    
    def edit_user(self):
        """Редактирование пользователя"""
        selection = self.users_tree.selection()
        if not selection:
            messagebox.showwarning("Ошибка", "Выберите пользователя для редактирования")
            return
        
        # В реальном приложении нужно реализовать редактирование
        messagebox.showinfo("Информация", "Редактирование пользователей будет реализовано в полной версии")
    
    def delete_user(self):
        """Удаление пользователя"""
        selection = self.users_tree.selection()
        if not selection:
            messagebox.showwarning("Ошибка", "Выберите пользователя для удаления")
            return
        
        item = self.users_tree.item(selection[0])
        user_id = item['values'][0]
        username = item['values'][1]
        
        if messagebox.askyesno("Подтверждение", f"Удалить пользователя {username}?"):
            try:
                self.cursor.execute("DELETE FROM users WHERE user_id = %s", (user_id,))
                self.conn.commit()
                messagebox.showinfo("Успех", "Пользователь удален")
                self.load_users_data()
            except Exception as e:
                messagebox.showerror("Ошибка", f"Не удалось удалить пользователя:\n{str(e)}")
                self.conn.rollback()
    
    def add_student(self):
        """Диалог добавления ученика"""
        messagebox.showinfo("Информация", "Добавление учеников будет реализовано в полной версии")
    
    def add_teacher(self):
        """Диалог добавления учителя"""
        messagebox.showinfo("Информация", "Добавление учителей будет реализовано в полной версии")
    
    def add_class(self):
        """Диалог добавления класса"""
        messagebox.showinfo("Информация", "Добавление классов будет реализовано в полной версии")
    
    def add_grade(self):
        """Диалог добавления оценки"""
        dialog = tk.Toplevel(self.root)
        dialog.title("Добавить оценку")
        dialog.geometry("400x300")
        
        # Поля формы
        ttk.Label(dialog, text="Ученик:").grid(row=0, column=0, sticky="e", padx=5, pady=5)
        
        # Получаем список учеников
        try:
            self.cursor.execute("""
                SELECT student_id, first_name || ' ' || last_name as name
                FROM students
                ORDER BY last_name, first_name
            """)
            students = self.cursor.fetchall()
            student_names = [f"{name} (ID: {sid})" for sid, name in students]
        except:
            student_names = []
        
        student_combo = ttk.Combobox(dialog, values=student_names, width=30)
        student_combo.grid(row=0, column=1, padx=5, pady=5)
        if student_names:
            student_combo.set(student_names[0])
        
        ttk.Label(dialog, text="Предмет:").grid(row=1, column=0, sticky="e", padx=5, pady=5)
        
        # Получаем список предметов
        try:
            self.cursor.execute("SELECT subject_id, subject_name FROM subjects ORDER BY subject_name")
            subjects = self.cursor.fetchall()
            subject_names = [f"{name} (ID: {sid})" for sid, name in subjects]
        except:
            subject_names = []
        
        subject_combo = ttk.Combobox(dialog, values=subject_names, width=30)
        subject_combo.grid(row=1, column=1, padx=5, pady=5)
        if subject_names:
            subject_combo.set(subject_names[0])
        
        ttk.Label(dialog, text="Оценка:").grid(row=2, column=0, sticky="e", padx=5, pady=5)
        grade_combo = ttk.Combobox(dialog, values=["5", "4", "3", "2", "1"], width=10)
        grade_combo.grid(row=2, column=1, sticky="w", padx=5, pady=5)
        grade_combo.set("5")
        
        ttk.Label(dialog, text="Тип:").grid(row=3, column=0, sticky="e", padx=5, pady=5)
        type_combo = ttk.Combobox(dialog, values=["текущая", "контрольная", "четвертная", "полугодовая", "годовая", "экзамен"], width=20)
        type_combo.grid(row=3, column=1, sticky="w", padx=5, pady=5)
        type_combo.set("текущая")
        
        ttk.Label(dialog, text="Тема урока:").grid(row=4, column=0, sticky="e", padx=5, pady=5)
        topic_entry = ttk.Entry(dialog, width=30)
        topic_entry.grid(row=4, column=1, padx=5, pady=5)
        
        def save_grade():
            student_str = student_combo.get()
            subject_str = subject_combo.get()
            grade_value = grade_combo.get()
            grade_type = type_combo.get()
            topic = topic_entry.get()
            
            if not student_str or not subject_str or not grade_value:
                messagebox.showwarning("Ошибка", "Заполните обязательные поля")
                return
            
            try:
                student_id = int(student_str.split("(ID: ")[1].rstrip(")"))
                subject_id = int(subject_str.split("(ID: ")[1].rstrip(")"))
                
                self.cursor.execute("""
                    INSERT INTO grades (student_id, subject_id, teacher_id, grade_value, grade_type, lesson_topic, grade_date)
                    VALUES (%s, %s, %s, %s, %s, %s, CURRENT_DATE)
                """, (student_id, subject_id, self.current_user['related_id'], int(grade_value), grade_type, topic))
                
                self.conn.commit()
                messagebox.showinfo("Успех", "Оценка добавлена")
                dialog.destroy()
                self.load_grades_for_class()
                
            except Exception as e:
                messagebox.showerror("Ошибка", f"Не удалось добавить оценку:\n{str(e)}")
                self.conn.rollback()
        
        # Кнопки
        button_frame = ttk.Frame(dialog)
        button_frame.grid(row=5, column=0, columnspan=2, pady=20)
        
        ttk.Button(button_frame, text="Сохранить", command=save_grade).pack(side="left", padx=5)
        ttk.Button(button_frame, text="Отмена", command=dialog.destroy).pack(side="left", padx=5)
    
    def add_homework(self):
        """Диалог добавления домашнего задания"""
        messagebox.showinfo("Информация", "Добавление домашних заданий будет реализовано в полной версии")
    
    def review_homework(self):
        """Проверка домашних заданий"""
        selection = self.homework_tree.selection()
        if not selection:
            messagebox.showwarning("Ошибка", "Выберите задание для проверки")
            return
        
        messagebox.showinfo("Информация", "Проверка заданий будет реализована в полной версии")
    
    def submit_homework(self):
        """Сдача домашнего задания"""
        messagebox.showinfo("Информация", "Сдача заданий будет реализована в полной версии")
    
    # ============= ОСНОВНЫЕ МЕТОДЫ =============
    
    def clear_window(self):
        """Очистка окна"""
        for widget in self.root.winfo_children():
            widget.destroy()
    
    def logout(self):
        """Выход из системы"""
        self.current_user = None
        self.current_role = None
        if self.cursor:
            self.cursor.close()
        if self.conn:
            self.conn.close()
        self.show_login_window()
    
    def refresh_data(self):
        """Обновление данных"""
        if self.current_role == 'admin':
            self.show_admin_view()
        elif self.current_role == 'teacher':
            self.show_teacher_view()
        elif self.current_role == 'student':
            self.show_student_view()
        elif self.current_role == 'parent':
            self.show_parent_view()
    
    def run(self):
        """Запуск приложения"""
        self.root.mainloop()

# Запуск приложения
if __name__ == "__main__":
    app = SchoolDatabaseApp()
    app.run()

### <a id="conclusion">Заключение</a>

В результате выполнения курсовой работы была разработана база данных для учета успеваемости школьников, которая отвечает современным требованиям образовательного процесса. Основные достижения и выводы работы:

- **Анализ предметной области**: Проведен детальный анализ существующих методов учета успеваемости, что позволило выявить ключевые проблемы и требования пользователей к системе.

- **Проектирование структуры базы данных**: Создана логическая и физическая структура базы данных, включающая таблицы для администраторов, классов, учителей, учеников, предметов и оценок. Все таблицы нормализованы до третьей нормальной формы, что обеспечивает целостность и согласованность данных.

- **Реализация функционала**: Разработаны функции для ввода и обновления данных, а также представления для анализа успеваемости. Это позволяет пользователям легко управлять информацией и получать необходимые отчеты.

- **Обеспечение безопасности**: Внедрена система прав доступа, что гарантирует защиту конфиденциальной информации о школьниках и их успеваемости.

- **Тестирование и документация**: Проведено тестирование базы данных на корректность выполнения операций и целостность данных. Подготовлена техническая документация, что обеспечит удобство в использовании системы и поможет в обучении новых пользователей.

Таким образом, разработанная база данных является эффективным инструментом для управления успеваемостью школьников, что способствует оптимизации учебного процесса и повышению качества образования.

## <a id="literature">Список использованных информационных источников</a>

1. **Онлайн-ресурсы:**
   - PostgreSQL. (n.d.). *PostgreSQL Documentation*. Retrieved from [https://www.postgresql.org/docs/](https://www.postgresql.org/docs/)
   - Хабр. (n.d.). *Индексы в PostgreSQL*. Retrieved from [https://habr.com/ru/companies/postgrespro/articles/326096/](https://habr.com/ru/companies/postgrespro/articles/326096/)
   - SQL-Ex blog. (n.d.). *Функции PostgreSQL: сила функций пользователя*. Retrieved from [https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html](https://sql-ex.com/blogs/?/Funkcii_PostgreSQL_sila_funkcij_polzovatelJa.html)

2. **Справочные системы:**
   - future-step.ru [https://future-step.ru/tutor/task-3-1/]
   - proglib.io [https://proglib.io/p/rukovodstvo-po-sql-dlya-nachinayushchih-chast-1-sozdanie-bazy-dannyh-tablic-i-ustanovka-svyazey-mezhdu-tablicami-2022-02-07]
   - github.com [https://github.com/Ekaterinagele/Databases/blob/main/README.md]
  
## <a id="applications">Приложения</a>

#### Приложение 4: SQL-запросы на заполнение таблиц

В этом приложении представлены SQL-запросы для заполнения таблиц.

[SQL-запросы] ("D:\курсач\бд")


